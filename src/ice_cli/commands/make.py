from __future__ import annotations

# ruff: noqa: E402

"""`ice make` – ergonomic scaffolding helpers.

This module introduces a *make* Typer app that wraps existing lower-level
command implementations so users can bootstrap entire workspaces with a
single, memorable namespace:

    ice make env MyWorkspace     # workspace skeleton
    ice make chain MyChain       # thin alias around `sdk create-chain`
    ice make node MyNode         # alias around `sdk create-node`
    ice make tool MyTool         # alias around `tool create`

Where possible we delegate to existing helpers to avoid code duplication and
respect repo rule 4 (no `app.*` imports inside `ice_sdk.*`).
"""

import textwrap
from pathlib import Path
from typing import Optional

import typer
from rich import print as rprint

from ice_cli.commands.tool import tool_create
from ice_cli.context import get_ctx

# ---------------------------------------------------------------------------
# Typer application ---------------------------------------------------------
# ---------------------------------------------------------------------------

make_app = typer.Typer(
    help=(
        "High-level scaffolding commands that combine existing *tool*, *node*,\n"
        "and *chain* generators under one intuitive namespace.\n\n"
        "Examples:\n"
        "  ice make env MyWorkspace\n"
        "  cd MyWorkspace && ice make chain Analytics --nodes 3\n"
    )
)

__all__ = ["make_app"]

# ---------------------------------------------------------------------------
# Utility helpers -----------------------------------------------------------
# ---------------------------------------------------------------------------


def _pretty_path(p: Path) -> str:  # noqa: D401 – helper
    try:
        return str(p.relative_to(Path.cwd()))
    except ValueError:
        return str(p)


# ---------------------------------------------------------------------------
# `make env` ----------------------------------------------------------------
# ---------------------------------------------------------------------------


@make_app.command("env", help="Scaffold a new iceOS workspace")
def make_env(
    name: str = typer.Argument(..., help="Workspace directory name"),
    force: bool = typer.Option(False, "--force", "-f", help="Overwrite if exists"),
):
    """Create *name*/ with standard sub-directories and minimal config files."""

    ctx = get_ctx()
    workspace = Path(name).resolve()

    if workspace.exists() and not force:
        rprint(
            f"[red]Error:[/] Directory {_pretty_path(workspace)} already exists. Use --force to overwrite."
        )
        raise typer.Exit(1)

    # Honour --dry-run ------------------------------------------------------
    if getattr(ctx, "dry_run", False):
        rprint(f"[yellow]Dry-run:[/] Would create workspace {_pretty_path(workspace)}")
        raise typer.Exit()

    # Create directories ----------------------------------------------------
    (workspace / "chains").mkdir(parents=True, exist_ok=True)
    (workspace / "nodes").mkdir(parents=True, exist_ok=True)
    (workspace / "tools").mkdir(parents=True, exist_ok=True)

    # Touch .env & chains.toml ---------------------------------------------
    env_path = workspace / ".env"
    env_path.touch(exist_ok=True)

    chains_manifest = workspace / "chains.toml"
    if not chains_manifest.exists() or force:
        chains_manifest.write_text("# Auto-generated by `ice make env`\n[chains]\n")

    rprint(f"[green]✔[/] Workspace created at {_pretty_path(workspace)}")


# ---------------------------------------------------------------------------
# `make chain` --------------------------------------------------------------
# ---------------------------------------------------------------------------


@make_app.command(
    "chain", help="Scaffold a new ScriptChain (alias for sdk create-chain)"
)
def make_chain(
    name: str = typer.Argument(..., help="Chain class / filename (without .py)"),
    directory: Optional[Path] = typer.Option(
        None,
        "--dir",
        "-d",
        exists=False,
        file_okay=False,
        dir_okay=True,
        writable=True,
        help="Destination directory (defaults to ./chains under CWD if present)",
    ),
    force: bool = typer.Option(False, "--force", "-f", help="Overwrite if exists"),
    builder: bool = typer.Option(
        False, "--builder", "-b", help="Run interactive Chain Builder"
    ),
    nodes: int | None = typer.Option(
        None, "--nodes", "-n", min=1, help="Preset node count for builder"
    ),
):
    """Delegate to *sdk_create_chain* while auto-detecting workspace layout."""

    if directory is None:
        # Prefer ./chains if present – fall back to CWD
        default_dir = Path.cwd() / "chains"
        directory = default_dir if default_dir.exists() else Path.cwd()

    # Directly call the existing helper to avoid sub-process overhead
    from ice_cli.cli import sdk_create_chain  # noqa: WPS433 – local import

    sdk_create_chain(  # type: ignore[arg-type, call-arg]
        name=name,
        directory=directory,
        force=force,
        builder=builder,
        nodes=nodes,
    )

    # Append entry to chains.toml if inside a workspace ---------------------
    manifest = Path.cwd() / "chains.toml"
    if manifest.exists():
        rel_path = Path("chains") / f"{name}.chain.py"
        # Write as simple key-value under [chains] -------------------------
        manifest_text = manifest.read_text()
        # Ensure [chains] header present ----------------------------------
        if "[chains]" not in manifest_text:
            manifest_text += "\n[chains]\n"
        entry_line = f'{name} = "{rel_path.as_posix()}"'
        if entry_line not in manifest_text:
            with manifest.open("a", encoding="utf-8") as fh:
                fh.write(entry_line + "\n")


# ---------------------------------------------------------------------------
# `make node` ---------------------------------------------------------------
# ---------------------------------------------------------------------------


@make_app.command("node", help="Scaffold a new node config (alias for sdk create-node)")
def make_node(
    name: str = typer.Argument(..., help="Human-readable node id/name"),
    type_: str = typer.Option(
        None, "--type", "-t", help="ai | tool | agent", case_sensitive=False
    ),
    chain: Optional[str] = typer.Option(
        None, "--chain", "-c", help="Add node to this chain"
    ),
    directory: Optional[Path] = typer.Option(
        None,
        "--dir",
        "-d",
        exists=False,
        file_okay=False,
        dir_okay=True,
        writable=True,
        help="Destination directory (defaults to ./nodes if present)",
    ),
    force: bool = typer.Option(False, "--force", "-f", help="Overwrite if exists"),
    interactive: bool = typer.Option(
        False, "--interactive", "-i", help="Interactive wizard"
    ),
):
    """Thin wrapper around *sdk_create_node* with workspace-aware defaults."""

    if directory is None:
        node_dir = Path.cwd() / "nodes"
        directory = node_dir if node_dir.exists() else Path.cwd()

    from ice_cli.cli import sdk_create_node  # noqa: WPS433 – local import

    sdk_create_node(  # type: ignore[arg-type, call-arg]
        name=name,
        type_=type_,
        directory=directory,
        force=force,
        interactive=interactive,
    )

    # If --chain supplied, inject import into chain file --------------------
    if chain:
        chain_path = Path.cwd() / "chains" / f"{chain}.chain.py"
        if chain_path.exists():
            _inject_node_into_chain(chain_path, name)
        else:
            rprint(
                f"[yellow]Warning:[/] Chain '{chain}' not found under ./chains – skipping auto-link."
            )


# ---------------------------------------------------------------------------
# `make tool` ---------------------------------------------------------------
# ---------------------------------------------------------------------------


@make_app.command("tool", help="Scaffold a new tool module (alias for tool create)")
def make_tool(
    name: str = typer.Argument(..., help="Class name for the tool (e.g. MyCool)"),
    directory: Optional[Path] = typer.Option(
        None,
        "--dir",
        "-d",
        exists=False,
        file_okay=False,
        dir_okay=True,
        writable=True,
        help="Destination directory (defaults to ./tools if present)",
    ),
    force: bool = typer.Option(False, "--force", "-f", help="Overwrite if exists"),
):
    """Delegate to existing *tool create* implementation."""

    if directory is None:
        tool_dir = Path.cwd() / "tools"
        directory = tool_dir if tool_dir.exists() else Path.cwd()

    tool_create(  # type: ignore[arg-type, call-arg]
        name=name,
        directory=directory,
        force=force,
    )


# ---------------------------------------------------------------------------
# Internal helper: inject node import --------------------------------------
# ---------------------------------------------------------------------------


def _inject_node_into_chain(
    chain_file: Path, node_name: str
) -> None:  # noqa: D401 – helper
    """Append an import stub for *node_name* into *chain_file* if missing."""

    marker = "# *** ice make auto-imports ***"
    class_name = node_name if node_name.endswith("Node") else f"{node_name}Node"

    import_stub = textwrap.dedent(
        f"""
        # *** ice make auto-imports ***
        from nodes.{node_name.lower()} import {class_name}
        """
    )

    src = chain_file.read_text()
    if marker in src:
        # Already injected once – no action
        return

    with chain_file.open("a", encoding="utf-8") as fh:
        fh.write(import_stub)

    rprint(f"[green]✔[/] Linked node '{node_name}' → {_pretty_path(chain_file)}")
