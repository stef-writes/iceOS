"""Scaffolder commands for new tools/agents/workflows.

Only *tool* is implemented for the first iteration – additional types can be
added by extending TEMPLATE_MAP and `_create_from_template`.
"""
from __future__ import annotations

import re
import textwrap
from pathlib import Path
from string import Template
from typing import Final

import click

# ---------------------------------------------------------------------------
# Naming patterns -----------------------------------------------------------
# ---------------------------------------------------------------------------

_TOOL_REGEX: Final[re.Pattern[str]] = re.compile(r"^[a-z][_a-z0-9]*_tool$")


# ---------------------------------------------------------------------------
# Templates -----------------------------------------------------------------
# ---------------------------------------------------------------------------

_TOOL_TEMPLATE: Final[str] = textwrap.dedent(
    '''"""${description}

Auto-generated by `ice new tool`.
"""

from __future__ import annotations

from typing import Any, Dict

from pydantic import Field, PositiveFloat

from ice_core.base_tool import ToolBase
from ice_core.models.enums import NodeType
from ice_core.unified_registry import registry


class ${class_name}(ToolBase):
    """${description}"""

    # --- Metadata -------------------------------------------------------
    name: str = "${registry_name}"
    description: str = Field("${description}")

    # --- Config ---------------------------------------------------------
    margin_percent: PositiveFloat = Field(25.0, description="Pricing margin percent")

    async def _execute_impl(self, *, cost: float) -> Dict[str, Any]:  # noqa: D401
        """Compute output based on *cost* and *margin_percent*."""
        price = cost * (1 + self.margin_percent / 100.0)
        return {"price": round(price, 2)}


# Factory function for creating ${class_name} instances
def create_${registry_name}_tool(**kwargs: Any) -> ${class_name}:
    """Create a ${class_name} with the specified configuration."""
    return ${class_name}(**kwargs)

# Auto-registration -----------------------------------------------------------
from ice_core.unified_registry import register_tool_factory

register_tool_factory("${registry_name}", "ice_tools.generated.${registry_name}:create_${registry_name}_tool")
''')

# ---------------------------------------------------------------------------
# Additional templates -------------------------------------------------------
# ---------------------------------------------------------------------------

_AGENT_TEMPLATE: Final[str] = textwrap.dedent(
    '''"""${description}

Auto-generated by `ice new agent`.
"""

from __future__ import annotations
from typing import List, Dict, Any
from ice_core.protocols.agent import IAgent
from ice_core.unified_registry import global_agent_registry

class ${class_name}(IAgent):
    """${description}"""

    name: str = "${registry_name}"
    system_prompt: str = "${system_prompt}"
    tools: List[str] = ${tools}

    async def think(self, context: Dict[str, Any]) -> str:
        """Implement agent reasoning logic."""
        # TODO: implement reasoning loop
        return "Agent thinking..."

    def allowed_tools(self) -> List[str]:
        """Return list of tool names this agent can use."""
        return ${tools}

# Factory function for creating ${class_name} instances
def create_${registry_name}_agent(**kwargs: Any) -> ${class_name}:
    """Create a ${class_name} with the specified configuration."""
    return ${class_name}(**kwargs)

# Auto-registration -----------------------------------------------------------
from ice_core.unified_registry import register_agent_factory

register_agent_factory("${registry_name}", "${module_path}:create_${registry_name}_agent")
''')

_AGENT_TOOL_TEMPLATE: Final[str] = textwrap.dedent(
    '''"""Tool wrapper exposing agent `${agent_name}` as a tool."""

from __future__ import annotations
from typing import Any, Dict, List

from ice_core.base_tool import ToolBase
from ice_core.unified_registry import global_agent_registry

class ${class_name}AgentTool(ToolBase):
    name: str = "agent_tool::${agent_name}"
    description: str = "Agent wrapper tool"

    async def _execute_impl(self, *, messages: List[Dict[str, str]]) -> Dict[str, Any]:  # noqa: D401
        agent = global_agent_registry.get_agent_instance("${agent_name}")
        reply = await agent.think({"messages": messages})
        return {"reply": reply}

# Factory function for creating ${class_name}AgentTool instances
def create_${registry_name}_agent_tool(**kwargs: Any) -> ${class_name}AgentTool:
    """Create a ${class_name}AgentTool with the specified configuration."""
    return ${class_name}AgentTool(**kwargs)

# Auto-registration -----------------------------------------------------------
from ice_core.unified_registry import register_tool_factory

register_tool_factory("agent_tool::${agent_name}", "${module_path}:create_${registry_name}_agent_tool")
''')

_LLM_OP_TEMPLATE: Final[str] = textwrap.dedent(
    '''"""${description}"""

from __future__ import annotations
from typing import Any, Dict
from pydantic import Field
from ice_core.base_tool import ToolBase

class ${class_name}LLMOperator(ToolBase):
    name: str = "${registry_name}"
    description: str = Field("${description}")
    model: str = "${model}"

    async def _execute_impl(self, *, prompt: str) -> Dict[str, Any]:  # noqa: D401
        return {"completion": f"Echo: {prompt}"}

# Factory function for creating ${class_name}LLMOperator instances
def create_${registry_name}_llm_operator(**kwargs: Any) -> ${class_name}LLMOperator:
    """Create a ${class_name}LLMOperator with the specified configuration."""
    return ${class_name}LLMOperator(**kwargs)

# Auto-registration -----------------------------------------------------------
from ice_core.unified_registry import register_tool_factory

register_tool_factory("${registry_name}", "ice_tools.generated.${registry_name}:create_${registry_name}_llm_operator")
''')

TEMPLATE_MAP: Final[dict[str, str]] = {
    "tool": _TOOL_TEMPLATE,
    "agent": _AGENT_TEMPLATE,
    "agent-tool": _AGENT_TOOL_TEMPLATE,
    "llm-operator": _LLM_OP_TEMPLATE,
}

# ---------------------------------------------------------------------------
# Helpers -------------------------------------------------------------------
# ---------------------------------------------------------------------------

def _snake_to_pascal(name: str) -> str:
    return "".join(part.capitalize() for part in name.split("_"))


def _validate_tool_name(name: str) -> None:
    if not _TOOL_REGEX.match(name):
        raise click.UsageError(
            "Tool name must match pattern '<domain>_<verb>_tool' and be lowercase alphanum+underscore."
        )


def _create_from_template(kind: str, name: str, description: str, output_dir: Path, **extra: object) -> Path:
    if kind not in TEMPLATE_MAP:
        raise click.ClickException(f"Unsupported scaffold type: {kind}")

    class_name_base = _snake_to_pascal(name)
    registry_name_base = name

    # Allow caller to override names via **extra
    class_name = extra.pop("class_name", class_name_base)
    registry_name = extra.pop("registry_name", registry_name_base)

    template = Template(TEMPLATE_MAP[kind])
    rendered = template.substitute(
        class_name=class_name,
        registry_name=registry_name,
        description=description,
        **extra,
    )

    rel_path = Path("src/ice_tools/generated") / f"{name}.py"
    abs_path = output_dir / rel_path
    abs_path.parent.mkdir(parents=True, exist_ok=True)

    # Ensure package __init__.py exists so recursive import picks up scaffolds
    pkg_init = abs_path.parent / "__init__.py"
    if not pkg_init.exists():
        pkg_init.write_text(
        '"""Package for generated scaffolds."""\n'
        'from importlib import import_module\n'
        'import pkgutil as _pkgutil\n'
        'for _m in _pkgutil.iter_modules(__path__):\n'
        '    import_module(f"{__name__}.{_m.name}")\n'
    )

    abs_path.write_text(rendered)
    return rel_path

# ---------------------------------------------------------------------------
# Click command -------------------------------------------------------------
# ---------------------------------------------------------------------------

@click.group(help="Scaffold new project components (tools/agents/workflows).")
def new() -> None:  # noqa: D401 (imperative)
    """CLI group registered under *ice* root."""


@new.command("tool")
@click.argument("name")
@click.option("--description", "description", default="Auto-generated tool", help="Docstring description.")
@click.option("--output-dir", type=click.Path(file_okay=False, dir_okay=True, path_type=Path), default=Path.cwd())
@click.option("--dry-run", is_flag=True, help="Print generated code without writing files.")
def scaffold_tool(name: str, description: str, output_dir: Path, dry_run: bool) -> None:  # noqa: D401
    """Generate a new Tool skeleton.

    NAME must follow the `<domain>_<verb>_tool` pattern.
    """
    _validate_tool_name(name)

    rel_path = _create_from_template("tool", name, description, output_dir)

    if dry_run:
        click.echo(Path(output_dir / rel_path).read_text())
    else:
        click.echo(f"✅ Created {rel_path}")
        click.echo("Next steps: implement _execute_impl and add tests.")

# ---------------------------------------------------------------------------
# Agent scaffold -------------------------------------------------------------
# ---------------------------------------------------------------------------

@new.command("agent")
@click.argument("name")
@click.option("--description", default="Auto-generated agent")
@click.option("--system-prompt", default="You are a helpful agent.")
@click.option("--tools", multiple=True, help="Tool names available to the agent.")
@click.option("--output-dir", type=click.Path(file_okay=False, dir_okay=True, path_type=Path), default=Path.cwd())
def scaffold_agent(name: str, description: str, system_prompt: str, tools: tuple[str], output_dir: Path) -> None:  # noqa: D401
    """Generate agent skeleton."""
    agent_name = name if name.endswith("_agent") else f"{name}_agent"
    class_name = _snake_to_pascal(agent_name)
    module_path = f"ice_tools.generated.{agent_name}"
    rel = _create_from_template(
        "agent",
        agent_name,
        description,
        output_dir,
        system_prompt=system_prompt,
        tools=list(tools),
        module_path=module_path,
    )
    click.echo(f"✅ Created {rel}")

# ---------------------------------------------------------------------------
# Agent-tool scaffold --------------------------------------------------------
# ---------------------------------------------------------------------------

@new.command("agent-tool")
@click.argument("agent_name")
@click.option("--output-dir", type=click.Path(file_okay=False, dir_okay=True, path_type=Path), default=Path.cwd())
def scaffold_agent_tool(agent_name: str, output_dir: Path) -> None:  # noqa: D401
    """Generate tool wrapper around an existing agent."""
    class_prefix = _snake_to_pascal(agent_name)
    module_path = f"ice_tools.generated.{agent_name}_tool"
    rel = _create_from_template(
        "agent-tool",
        f"{agent_name}_tool",
        f"Wrapper for {agent_name}",
        output_dir,
        agent_name=agent_name,
        class_name=class_prefix,
        module_path=module_path,
    )
    click.echo(f"✅ Created {rel}")

# ---------------------------------------------------------------------------
# LLM operator scaffold ------------------------------------------------------
# ---------------------------------------------------------------------------

@new.command("llm-operator")
@click.argument("name")
@click.option("--description", default="Auto-generated LLM operator")
@click.option("--model", default="gpt-4o")
@click.option("--output-dir", type=click.Path(file_okay=False, dir_okay=True, path_type=Path), default=Path.cwd())
def scaffold_llm_operator(name: str, description: str, model: str, output_dir: Path) -> None:  # noqa: D401
    op_name = f"{name}_llm_operator"
    rel = _create_from_template(
        "llm-operator",
        op_name,
        description,
        output_dir,
        model=model,
        class_name=_snake_to_pascal(name),
        registry_name=op_name,
    )
    click.echo(f"✅ Created {rel}")
