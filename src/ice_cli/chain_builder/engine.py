"""Minimal engine for interactive *Chain Builder* M0.

The engine is UI-agnostic: it exposes :func:`ask_next` which returns a
question dict and :func:`submit_answer` which records the response.
A CLI wrapper (in ``ice_cli.cli``) feeds user answers via *questionary*.
"""

from __future__ import annotations

# ---------------------------------------------------------------------------
# Standard library imports ---------------------------------------------------
# ---------------------------------------------------------------------------

from dataclasses import dataclass, field
from typing import List, Optional

# Note: Imports below are only needed for type hints in the generated template
# string – they are not used at runtime within this module.  Suppress the
# unused-import warnings accordingly.  # noqa: F401
from ice_sdk.models.node_models import AiNodeConfig, ToolNodeConfig  # noqa: F401

__all__ = ["ChainDraft", "BuilderEngine", "Question"]


@dataclass
class Question:  # noqa: D401 – simple container
    key: str
    prompt: str
    choices: Optional[List[str]] = None  # None → free text


@dataclass
class ChainDraft:  # noqa: D401 – mutable builder state
    name: str = "my_chain"
    nodes: List[dict] = field(default_factory=list)  # hold raw answers per node
    current_step: int = 0
    total_nodes: int = 0


class BuilderEngine:  # noqa: D401 – stateless helper
    """Simple state machine for M0 (linear ai/tool nodes)."""

    @staticmethod
    def start(total_nodes: int, chain_name: str | None = None) -> ChainDraft:
        cd = ChainDraft(name=chain_name or "my_chain", total_nodes=total_nodes)
        return cd

    # ------------------------------------------------------------------
    # Question flow -----------------------------------------------------
    # ------------------------------------------------------------------
    @staticmethod
    def next_question(draft: ChainDraft) -> Optional[Question]:  # noqa: D401
        if draft.current_step == 0:
            return Question(key="type", prompt="Node type", choices=["ai", "tool"])
        elif draft.current_step == 1:
            return Question(key="name", prompt="Node name")
        elif draft.current_step == 2:
            return Question(key="model", prompt="Model (ai only)")
        else:
            return None

    @staticmethod
    def submit_answer(draft: ChainDraft, key: str, answer: str) -> None:  # noqa: D401
        step_map = {0: "type", 1: "name", 2: "model"}
        current_key = step_map.get(draft.current_step)
        if key != current_key:
            return
        if draft.current_step == 0:
            draft.nodes.append({"type": answer})
        elif draft.current_step == 1:
            draft.nodes[-1]["name"] = answer
        elif draft.current_step == 2:
            if draft.nodes[-1]["type"] == "ai":
                draft.nodes[-1]["model"] = answer
        draft.current_step += 1
        if draft.current_step > 2:
            draft.current_step = 0  # next node
        
    # ------------------------------------------------------------------
    # Render -------------------------------------------------------------
    # ------------------------------------------------------------------
    @staticmethod
    def render_chain(draft: ChainDraft) -> str:  # noqa: D401
        """Return Python source code for the ScriptChain."""
        import textwrap

        node_lines: List[str] = []
        for idx, node in enumerate(draft.nodes):
            node_id = f"n{idx}"
            if node["type"] == "ai":
                node_lines.append(
                    f"    AiNodeConfig(id=\"{node_id}\", type=\"ai\", name=\"{node['name']}\", model=\"{node.get('model','gpt-3.5-turbo')}\", prompt=\"# TODO\", llm_config={{'provider': 'openai'}}),"
                )
            else:
                node_lines.append(
                    f"    ToolNodeConfig(id=\"{node_id}\", type=\"tool\", name=\"{node['name']}\", tool_name=\"echo\", tool_args={{}}),"
                )

        nodes_block = "\n".join(node_lines)
        template = f'"""{draft.name} – generated by Chain Builder"""\n\nfrom __future__ import annotations\n\nfrom typing import List\n\nfrom ice_orchestrator.script_chain import ScriptChain\nfrom ice_sdk.models.node_models import AiNodeConfig, ToolNodeConfig\nfrom ice_sdk.tools.builtins.deterministic import SumTool\n\nnodes: List[AiNodeConfig | ToolNodeConfig] = [\n{nodes_block}\n]\n\nif __name__ == "__main__":\n    chain = ScriptChain(nodes=nodes, tools=[SumTool()], name="{draft.name}")\n    import asyncio, rich; rich.print(asyncio.run(chain.execute()).model_dump())\n'
        return textwrap.dedent(template) 