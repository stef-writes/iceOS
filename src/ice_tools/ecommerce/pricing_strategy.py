"""PricingStrategyTool – compute selling price from cost with margin & rounding.

This is the *first* concrete tool in the e-commerce toolkit rebuild.  The
interface is a refined version of the original implementation that was recently
removed.  It remains deterministic and therefore **cache-friendly** in the
orchestrator.

Design decisions
================
* Pure function: all logic happens inside `_execute_impl`; no external I/O.
* Uses *decimal* for correct monetary rounding (banker’s rounding not desired
  – we use ROUND_HALF_UP).
* Configurable parameters are expressed as **Pydantic fields** so they appear
  in autogenerated JSON-Schema and UI forms.
* An instance is auto-registered with the global `registry` so it is
  discoverable via `GET /api/v1/tools` without extra ceremony.

The unit tests live in ``tests/unit/ice_tools/test_pricing_strategy_tool.py``.
"""
from __future__ import annotations

from decimal import Decimal, ROUND_HALF_UP
from typing import Any, Dict

from pydantic import Field, PositiveFloat, validator

from ice_core.base_tool import ToolBase
from ice_core.exceptions import ValidationError
from ice_core.models.enums import NodeType
from ice_core.unified_registry import registry

__all__: list[str] = ["PricingStrategyTool"]


class PricingStrategyTool(ToolBase):
    """Calculate a marketplace price given *cost* and config parameters.

    Parameters (config)
    -------------------
    margin_percent : float, default=25.0
        Desired gross margin (e.g. 25 → 25 %).  Must be ≥ 0.
    min_price : float, default=0.99
        Lower bound for the final price – ensures profitability / marketplace
        constraint compliance.
    decimal_places : int, default=2
        How many decimal places to round to (0–4).

    Execution inputs
    ----------------
    cost : float
        Per-unit cost basis of the item.  Must be > 0.

    Returns
    -------
    dict
        ``{"price": float}`` – rounded according to *decimal_places*.
    """

    # Metadata ----------------------------------------------------------------
    name: str = "pricing_strategy"
    description: str = "Compute sale price from cost using margin% and rounding rules."

    # Config fields -----------------------------------------------------------
    margin_percent: PositiveFloat = Field(25.0, description="Desired margin percentage")
    min_price: PositiveFloat = Field(0.99, description="Minimum allowed price")
    decimal_places: int = Field(2, ge=0, le=4, description="Decimal precision for rounding")

    # Validators --------------------------------------------------------------
    @validator("margin_percent")  # noqa: D401 – imperative
    def _non_negative(cls, v: float) -> float:  # pylint: disable=no-self-argument
        if v < 0:
            raise ValueError("margin_percent cannot be negative")
        return v

    # Core execution ----------------------------------------------------------
    async def _execute_impl(self, *, cost: float) -> Dict[str, Any]:  # noqa: D401
        cost_raw = cost
        try:
            cost = float(cost_raw)
        except (TypeError, ValueError):
            raise ValidationError("'cost' must be a float > 0") from None

        if cost <= 0:
            raise ValidationError("'cost' must be > 0")

        margin_multiplier = 1 + (self.margin_percent / 100.0)
        raw_price = Decimal(str(cost * margin_multiplier))
        quant = Decimal("1").scaleb(-self.decimal_places)  # 1 → 0.01 for 2 dp
        final_price = raw_price.quantize(quant, rounding=ROUND_HALF_UP)

        if final_price < Decimal(str(self.min_price)):
            final_price = Decimal(str(self.min_price)).quantize(quant, rounding=ROUND_HALF_UP)

        return {"price": float(final_price)}


# Auto-registration -----------------------------------------------------------
_instance = PricingStrategyTool()  # default config
registry.register_instance(NodeType.TOOL, _instance.name, _instance, validate=False)  # type: ignore[arg-type]
