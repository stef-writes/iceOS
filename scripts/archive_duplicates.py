#!/usr/bin/env python3
"""Archive duplicate/deprecated files instead of deleting them.

This script:
1. Creates an _archive directory structure
2. Moves deprecated files while preserving paths
3. Leaves a DEPRECATED.md file in place of moved files
4. Generates a migration guide
"""

import json
import shutil
from datetime import datetime
from pathlib import Path


class CodeArchiver:
    def __init__(self, root_path: Path):
        self.root = root_path
        self.archive_root = root_path / "_archive" / datetime.now().strftime("%Y%m%d_%H%M%S")
        self.migrations = []
        
    def archive_files(self, files_to_archive: list) -> None:
        """Archive specified files with deprecation notices."""
        print(f"üìÅ Creating archive at: {self.archive_root}")
        self.archive_root.mkdir(parents=True, exist_ok=True)
        
        for file_info in files_to_archive:
            if isinstance(file_info, dict):
                old_path = Path(file_info['old'])
                new_path = file_info.get('new', '')
                reason = file_info.get('reason', 'Deprecated')
            else:
                old_path = Path(file_info)
                new_path = ''
                reason = 'Deprecated'
            
            src = self.root / old_path
            if not src.exists():
                print(f"‚ö†Ô∏è  Skipping {old_path} (doesn't exist)")
                continue
                
            # Create archive destination
            dst = self.archive_root / old_path
            dst.parent.mkdir(parents=True, exist_ok=True)
            
            # Move file to archive
            shutil.copy2(src, dst)
            print(f"üì¶ Archived: {old_path}")
            
            # Create deprecation notice
            deprecation_content = f"""# DEPRECATED: {old_path.name}

**This file has been archived on {datetime.now().strftime('%Y-%m-%d')}**

## Reason
{reason}

## Migration Path
{f'Please use: `{new_path}`' if new_path else 'See migration guide for alternatives.'}

## Original Location
The original file has been moved to: `{dst.relative_to(self.root)}`

---
*This is an automated deprecation notice. Do not edit this file.*
"""
            
            with open(src, 'w') as f:
                f.write(deprecation_content)
            
            # Track migration
            self.migrations.append({
                "old": str(old_path),
                "new": new_path,
                "reason": reason,
                "archived_to": str(dst.relative_to(self.root)),
                "date": datetime.now().isoformat()
            })
    
    def generate_migration_guide(self) -> None:
        """Generate comprehensive migration guide."""
        guide_path = self.root / "MIGRATION_GUIDE.md"
        
        content = f"""# iceOS Migration Guide

Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Overview

This guide documents the consolidation of duplicate implementations and architectural improvements in iceOS.

## Archived Files

The following files have been archived to `{self.archive_root.relative_to(self.root)}`:

"""
        
        # Group by category
        nodes = [m for m in self.migrations if 'nodes/' in m['old']]
        registry = [m for m in self.migrations if 'registry' in m['old']]
        agents = [m for m in self.migrations if 'agents/' in m['old']]
        others = [m for m in self.migrations if m not in nodes + registry + agents]
        
        if nodes:
            content += "\n### Node Implementations\n\n"
            content += "Individual node files have been consolidated into the unified executor:\n\n"
            for m in nodes:
                content += f"- **{m['old']}**\n"
                content += f"  - New location: `{m['new']}`\n"
                content += f"  - Reason: {m['reason']}\n\n"
        
        if registry:
            content += "\n### Registry System\n\n"
            for m in registry:
                content += f"- **{m['old']}**\n"
                content += f"  - New location: `{m['new']}`\n"
                content += f"  - Reason: {m['reason']}\n\n"
        
        if agents:
            content += "\n### Agent System\n\n"
            for m in agents:
                content += f"- **{m['old']}**\n"
                content += f"  - New location: `{m['new']}`\n"
                content += f"  - Reason: {m['reason']}\n\n"
        
        if others:
            content += "\n### Other Files\n\n"
            for m in others:
                content += f"- **{m['old']}**\n"
                if m['new']:
                    content += f"  - New location: `{m['new']}`\n"
                content += f"  - Reason: {m['reason']}\n\n"
        
        content += """
## Migration Steps

### For Developers

1. **Update imports**: Change old imports to use new locations
   ```python
   # Old
   from ice_orchestrator.nodes.agent import AgentNode
   
   # New
   from ice_orchestrator.execution.executors.unified import agent_executor
   ```

2. **Update references**: Use new registry patterns
   ```python
   # Old
   from ice_core.registry import Registry
   
   # New
   from ice_core.unified_registry import registry
   ```

3. **Use unified patterns**: Leverage the consolidated architecture
   ```python
   # Register executors with unified registry
   @register_node("agent")
   async def agent_executor(...):
       ...
   ```

### For Tests

Update test imports and mocks to use new locations. The functionality remains the same, only the structure has changed.

## Benefits of This Migration

1. **Reduced Duplication**: Single source of truth for each component
2. **Cleaner Architecture**: Unified patterns across the codebase
3. **Better Maintainability**: Fewer files to update when making changes
4. **Improved Performance**: Optimized import paths and reduced overhead

## Need Help?

- Check the archived files in `_archive/` for original implementations
- Review the unified implementations in `executors/unified.py`
- See test updates for migration examples
"""
        
        with open(guide_path, 'w') as f:
            f.write(content)
        
        print(f"\nüìñ Migration guide created: {guide_path}")
        
        # Save migration data
        migration_data_path = self.archive_root / "migration_data.json"
        with open(migration_data_path, 'w') as f:
            json.dump(self.migrations, f, indent=2)


def main():
    """Archive duplicate files based on analysis."""
    root = Path(__file__).parent.parent
    
    # Files to archive based on our analysis (obsolete paths removed)
    files_to_archive = [
        # Old registry (moved to unified pattern)
        {
            "old": "src/ice_core/registry.py",
            "new": "src/ice_core/unified_registry.py",
            "reason": "Replaced with unified registry pattern"
        },
        
        # Duplicate memory implementations
        {
            "old": "src/ice_orchestrator/context/memory.py",
            "new": "src/ice_orchestrator/memory/base.py",
            "reason": "Memory system consolidated in memory/ directory"
        },
    ]
    
    archiver = CodeArchiver(root)
    
    print("üóÑÔ∏è  iceOS Code Archiver")
    print("=" * 50)
    
    # Archive files
    archiver.archive_files(files_to_archive)
    
    # Generate migration guide
    archiver.generate_migration_guide()
    
    print("\n‚úÖ Archiving complete!")
    print(f"üìÅ Archive location: {archiver.archive_root}")
    print("üìñ See MIGRATION_GUIDE.md for migration instructions")


if __name__ == "__main__":
    main() 